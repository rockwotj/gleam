---
source: compiler-core/src/cplusplus/tests/records.rs
expression: "\npub type Either(left_type, right_type) {\n  Left(v: left_type)\n  Right(v: right_type)\n}\n\npub fn make_left(v: left) {\n  Left(v)\n}\n\npub fn make_right(v: right) {\n  Right(v)\n}\n"
---
#ifndef MY_PACKAGE_MY_MODULE_H_
#define MY_PACKAGE_MY_MODULE_H_

#include <gleam.h>

namespace my {
namespace module {

template <typename T$8, typename T$9>
class Either;

template <typename T$8, typename T$9>
class Left;

template <typename T$8, typename T$9>
class Right;

template <typename T$10, typename T$15>
gleam::Ref<::my::module::Either<T$10, T$15>> make_left(T$10 v);

template <typename T$12, typename T$17>
gleam::Ref<::my::module::Either<T$17, T$12>> make_right(T$12 v);

template <typename T$8, typename T$9>
class Either {
public:
  Either() {}
  virtual ~Either() {}
  
private:
  
};

template <typename T$8, typename T$9>
class Left : public Either<T$8, T$9> {
public:
  Left(T$8 v) : Either<T$8, T$9>(), m$v(v) {}
  T$8 v() const { return m$v; }
private:
  T$8 m$v;
};

template <typename T$8, typename T$9>
class Right : public Either<T$8, T$9> {
public:
  Right(T$9 v) : Either<T$8, T$9>(), m$v(v) {}
  T$9 v() const { return m$v; }
private:
  T$9 m$v;
};

} // namespace my
} // namespace module

#endif // MY_PACKAGE_MY_MODULE_H_

---
#include "module.h"

namespace my {
namespace module {

template <typename T$10, typename T$15>
gleam::Ref<::my::module::Either<T$10, T$15>> make_left(T$10 v) {
  return gleam::MakeRef<::my::module::Left<T$10, T$15>>(v);
};

template <typename T$12, typename T$17>
gleam::Ref<::my::module::Either<T$17, T$12>> make_right(T$12 v) {
  return gleam::MakeRef<::my::module::Right<T$12, T$17>>(v);
};

} // namespace my
} // namespace module

